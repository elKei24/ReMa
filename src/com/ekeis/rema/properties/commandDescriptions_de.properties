#
# Copyright (c) 2016 by Elias Keis. All rights reserved.
#

cmd=Befehle
cmd.math=Arithmetik
cmd.math.add=ADD
cmd.math.add.text=addiert den Wert in Rx zum Wert in A, legt das Ergebnis in A \
ab, erhöht den Wert in BZ um 1
cmd.math.add.title=ADD x
cmd.math.div=DIV
cmd.math.mult=MULT
cmd.math.mult.text=multipliziert den Wert in Rx mit dem Wert in A, legt das \
Ergebnis in A ab, erhöht den Wert in BZ um 1
cmd.math.mult.title=MULT x
cmd.math.sub=SUB
cmd.math.sub.text=subtrahiert den Wert in Rx vom Wert in A, legt das Ergebnis \
in A ab, erhöht den Wert in BZ um 1
cmd.math.sub.title=SUB x
cmd.storage=Speicher
cmd.storage.dload=DLOAD
cmd.storage.dload.text=Lädt unmittelbar die Zahl i in A, erhöht den Wert in BZ um 1
cmd.storage.dload.title=DLOAD i
cmd.storage.load=LOAD
cmd.storage.load.text=Kopiert den Wert in Rx nach A, erhöht BZ um 1
cmd.storage.load.title=LOAD x
cmd.storage.store=STORE
cmd.storage.store.text=Kopiert den Wert in A nach Rx, erhöht den Wert in BZ um 1
cmd.storage.store.title=STORE x
cmd.math.div.text=dividiert den Wert in A durch den Wert in Rx (Ganzzahldivision \
ohne Rest), legt das Ergebnis in A ab, erhöht den Wert in BZ um 1
cmd.math.div.title=DIV x
cmd.jump=Sprünge
cmd.jump.jump=JUMP
cmd.jump.jump.title=JUMP n
cmd.jump.jump.text=Lädt die Zahl n in BZ, Programm wird mit Befehl in Speicherzelle \
n fortgesetzt. Es handelt sich um einen unbedingten Sprung.
cmd.jump.jge=JGE
cmd.jump.jge.title=JGE n
cmd.jump.jge.text=Lädt die Zahl n in BZ, falls der Wert in A größer oder gleich 0 ist, erhöht ansonsten den Wert in BZ um 1.\n\
  "JGE" steht für "Jump if greater or equal zero".
cmd.jump.jgt=JGT
cmd.jump.jgt.title=JGT n
cmd.jump.jgt.text=Lädt die Zahl n in BZ, falls der Wert in A größer 0 ist, erhöht ansonsten den Wert in BZ um 1.\n\
  "JGT" steht für "Jump if greater than zero".
cmd.jump.jle=JLE
cmd.jump.jle.title=JLE n
cmd.jump.jle.text=Lädt die Zahl n in BZ, falls der Wert in A kleiner oder gleich 0 ist, erhöht ansonsten den Wert in BZ um 1.\n\
  "JLE" steht für "Jump if less or equal zero".
cmd.jump.jlt=JLT
cmd.jump.jlt.title=JLT n
cmd.jump.jlt.text=Lädt die Zahl n in BZ, falls der Wert in A kleiner 0 ist, erhöht ansonsten den Wert in BZ um 1.\n\
  "JLT" steht für "Jump if less than zero".
cmd.jump.jeq=JEQ
cmd.jump.jeq.title=JEQ n
cmd.jump.jeq.text=Lädt die Zahl n in BZ, falls der Wert in A gleich 0 ist, erhöht ansonsten den Wert in BZ um 1.\n\
  "JEQ" steht für "Jump if equal zero".
cmd.jump.jne=JNE
cmd.jump.jne.title=JNE n
cmd.jump.jne.text=Lädt die Zahl n in BZ, falls der Wert in A ungleich 0 ist, erhöht ansonsten den Wert in BZ um 1.\n\
  "JNE" steht für "Jump if not equal zero".
cmd.end=END
cmd.end.title=END
cmd.end.text=Erhöht den Wert in BZ um 1 und beendet den Programmablauf.
cmd.debug.log=LOG
cmd.debug.log.title=LOG msg
cmd.debug.log.text=Gibt msg im Verlauf aus und erhöht BZ um 1. Kann beim Nachvollziehen des \
Ablaufs sinnvoll sein, ist aber eigentlich kein \
Bestandteil der Sprache.
cmd.debug.pause=PAUSE
cmd.debug.pause.title=PAUSE
cmd.debug.pause.text=Stoppt die Maschine, sodass mit einzelnen Schritten \
fortgefahren werden kann, und erhöht BZ um 1. Kann bei der Fehlersuche hilfreich \
sein, ist aber eigentlich nicht Bestandteil der Sprache.
cmd.debug=Fehlersuche
cmd.debug.comment=Kommentare
cmd.debug.comment.title=Kommentare
cmd.debug.comment.text=Benutze '#', '--' oder '//', um Kommentare hinzuzufügen.\n\
Kommentare sind eigentlich keine Befehle und werden \
vollständig ignoriert. Vor Kommentaren befindet sich keine \
Zeilennummber.
cmd.bitvise=Bitweise
cmd.bitvise.not.title=NOT
cmd.bitvise.not=NOT
cmd.bitvise.not.text=Führt eine logische Negierung der Bits im Akku durch und \
erhöht BZ um 1.
cmd.bitvise.and.title=AND x
cmd.bitvise.and=AND
cmd.bitvise.and.text=Führt eine logische UND-Operation mit den Bits in A und Rx \
durch und erhöht BZ um 1.\nEin Bit im Ergebnis ist 1, wenn \
in beiden zugehörigen Bits in A und Rx ebenfalls 1 steht.
cmd.bitvise.or.title=OR x
cmd.bitvise.or=OR
cmd.bitvise.or.text=Führt eine logische ODER-Operation mit den Bits in A und Rx \
durch und erhöht BZ um 1.\nEin Bit im Ergebnis ist 1, wenn \
mindestenst in einem der beiden zugehörigen Bits in A oder \
Rx ebenfalls 1 steht.
cmd.bitvise.xor.title=XOR x
cmd.bitvise.xor=XOR
cmd.bitvise.xor.text=Führt eine logische exklusive ODER-Operation mit den Bits in \
A und Rx durch und erhöht BZ um 1.\nEin Bit im Ergebnis ist \
1, wenn exakt in einem der beiden zugehörigen zugehörigen \
Bits in A und Rx ebenfalls 1 steht.
cmd.bitvise.asl.title=ASL
cmd.bitvise.asl=ASL
cmd.bitvise.asl.text=Führt eine arithmetische Linksverschiebung in A durch und erhöht BZ um 1.\n\
"ASL" steht für "Arithmetic Shift Left". Diese Operation \
entspricht einer Multiplikation mit 2. Arithmetische \
Linksverschiebung ist äquivalent zu logischer Linksverschiebung.
cmd.bitvise.asr.title=ASR
cmd.bitvise.asr=ASR
cmd.bitvise.asr.text=Führt eine arithmetische Rechtsverschiebung in A durch und \
erhöht BZ um 1.\n"ASR" steht für "Arithmetic Shift Right". \
Diese Operation entspricht einer Division durch 2 mit \
Abrundung. Im Gegensatz zur logischen Rechtsverschiebung \
werden bei arithmetischer Rechtverschiebung links nicht \
zwingend Nullen, sondern Kopien des Vorzeichenbits \
eingeschoben, sodass das Vorzeichen sich nicht ändert.
cmd.bitvise.lsr.title=LSR
cmd.bitvise.lsr=LSR
cmd.bitvise.lsr.text=Führt eine logische Rechtsverschiebung in A durch und erhöht \
BZ um 1.\n"LSR" steht für "Logical Shift Right". Diese \
Operation entspricht bei vorzeichenlosen Zahlen einer \
Division durch 2 mit Abrundung. In dieser Registermaschine \
wird allerdings ausschließlich mit vorzeichenbehafteten Zahlen \
gearbeitet. Im Gegensatz zur arithmetischen Rechtsverschiebung \
werden bei logischer Rechtverschiebung links ausschließlich Nullen \
nachgeschoben, sodass das sich das Vorzeichen ggf. ändert.